var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#General-functionalities","page":"API","title":"General functionalities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ReservoirSample\nupdate!\nvalue\nordered_value\nitsample","category":"page"},{"location":"api/#StreamSampling.ReservoirSample","page":"API","title":"StreamSampling.ReservoirSample","text":"ReservoirSample([rng], T, method = algL)\nReservoirSample([rng], T, n::Int, method = algL; ordered = false)\n\nInitializes a reservoir sample which can then be fitted with update!. The first signature represents a sample where only a single element is collected. Look at the Algorithms section for the supported methods.\n\n\n\n\n\n","category":"function"},{"location":"api/#StreamSampling.update!","page":"API","title":"StreamSampling.update!","text":"update!(rs::AbstractReservoirSample, el, [w])\n\nUpdates the reservoir sample by scanning the passed element. In the case of weighted sampling also the weight of the element needs to be passed to the function.\n\n\n\n\n\n","category":"function"},{"location":"api/#StreamSampling.value","page":"API","title":"StreamSampling.value","text":"value(rs::AbstractReservoirSample)\n\nReturns the elements collected in the sample at the current  sampling stage.\n\n\n\n\n\n","category":"function"},{"location":"api/#StreamSampling.ordered_value","page":"API","title":"StreamSampling.ordered_value","text":"ordered_value(rs::AbstractReservoirSample)\n\nReturns the elements collected in the sample at the current  sampling stage in the order they were collected. This applies only when ordered = true is passed in ReservoirSample.\n\n\n\n\n\n","category":"function"},{"location":"api/#StreamSampling.itsample","page":"API","title":"StreamSampling.itsample","text":"itsample([rng], iter, method = algL)\nitsample([rng], iter, weight, method = algAExpJ)\n\nReturn a random element of the iterator, optionally specifying a rng  (which defaults to Random.default_rng()) and a weight function which accept each element as input and outputs the corresponding weight. If the iterator is empty, it returns nothing.\n\n\n\nitsample([rng], iter, method = algL; ordered = false)\nitsample([rng], iter, wv, method = algAExpJ; ordered = false)\n\nReturn a vector of n random elements of the iterator,  optionally specifying a rng (which defaults to Random.default_rng()) and a method. ordered dictates whether an ordered sample (also called a sequential  sample, i.e. a sample where items appear in the same order as in iter) must be  collected.\n\nIf the iterator has less than n elements, in the case of sampling without replacement, it returns a vector of those elements.\n\n\n\n\n\n","category":"function"},{"location":"api/#Algorithms","page":"API","title":"Algorithms","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"StreamSampling.algL\nStreamSampling.algR\nStreamSampling.algRSWRSKIP\nStreamSampling.algAExpJ\nStreamSampling.algARes\nStreamSampling.algWRSWRSKIP","category":"page"},{"location":"api/#StreamSampling.algL","page":"API","title":"StreamSampling.algL","text":"Implements random sampling without replacement.\n\nAdapted from algorithm L described in \"Random sampling with a reservoir, J. S. Vitter, 1985\".\n\n\n\n\n\n","category":"constant"},{"location":"api/#StreamSampling.algR","page":"API","title":"StreamSampling.algR","text":"Implements random sampling without replacement. \n\nAdapted from algorithm R described in \"Random sampling with a reservoir, J. S. Vitter, 1985\".\n\n\n\n\n\n","category":"constant"},{"location":"api/#StreamSampling.algRSWRSKIP","page":"API","title":"StreamSampling.algRSWRSKIP","text":"Implements random sampling with replacement.\n\nAdapted fron algorithm RSWR_SKIP described in \"Reservoir-based Random Sampling with Replacement from  Data Stream, B. Park et al., 2008\".\n\n\n\n\n\n","category":"constant"},{"location":"api/#StreamSampling.algAExpJ","page":"API","title":"StreamSampling.algAExpJ","text":"Implements weighted random sampling without replacement.\n\nAdapted from algorithm A-ExpJ described in \"Weighted random sampling with a reservoir,  P. S. Efraimidis et al., 2006\".\n\n\n\n\n\n","category":"constant"},{"location":"api/#StreamSampling.algARes","page":"API","title":"StreamSampling.algARes","text":"Implements weighted random sampling without replacement.\n\nAdapted from algorithm A-Res described in \"Weighted random sampling with a reservoir,  P. S. Efraimidis et al., 2006\".\n\n\n\n\n\n","category":"constant"},{"location":"api/#StreamSampling.algWRSWRSKIP","page":"API","title":"StreamSampling.algWRSWRSKIP","text":"Implements weighted random sampling with replacement.\n\nAdapted from algorithm WRSWR_SKIP described in \"A Skip-based Algorithm for Weighted Reservoir  Sampling with Replacement, A. Meligrana, 2024\". \n\n\n\n\n\n","category":"constant"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package allows to sample from any stream in a single pass through the data, even if the number of items is unknown.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If the iterable is lazy, the memory required grows in relation to the size of the sample, instead of the all population, which can be useful for sampling from big data streams.","category":"page"},{"location":"#Example-Usage","page":"Introduction","title":"Example Usage","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The itsample instead allows to consume all the stream at once and return the sample collected:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using StreamSampling\n\njulia> st = 1:10;\n\njulia> itsample(st, 5)\n5-element Vector{Int64}:\n  9\n 15\n 52\n 96\n 91","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In some cases, one needs to control the updates the ReservoirSample will be subject to. In this case you can simply use the update! function to fit new values in the reservoir:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using StreamSampling\n\njulia> rs = ReservoirSample(Int, 5);\n\njulia> for x in 1:100\n           @inline update!(rs, x)\n       end\n\njulia> value(rs)\n5-element Vector{Int64}:\n  7\n  9\n 20\n 49\n 74","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Consult the API page for more information on the available functionalities.","category":"page"}]
}
