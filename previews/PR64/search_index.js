var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#General-functionalities","page":"API","title":"General functionalities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ReservoirSample\nupdate!\nvalue\nordered_value\nitsample","category":"page"},{"location":"api/#StreamSampling.ReservoirSample","page":"API","title":"StreamSampling.ReservoirSample","text":"ReservoirSample([rng], T, method = algL)\nReservoirSample([rng], T, n::Int, method = algL; ordered = false)\n\nInitializes a reservoir sample which can then be fitted with update!. The first signature represents a sample where only a single element is collected. Look at the Algorithms section for the supported methods.\n\n\n\n\n\n","category":"function"},{"location":"api/#StreamSampling.update!","page":"API","title":"StreamSampling.update!","text":"update!(rs::AbstractReservoirSample, el, [w])\n\nUpdates the reservoir sample by scanning the passed element. In the case of weighted sampling also the weight of the element needs to be passed to the function.\n\n\n\n\n\n","category":"function"},{"location":"api/#StreamSampling.value","page":"API","title":"StreamSampling.value","text":"value(rs::AbstractReservoirSample)\n\nReturns the elements collected in the sample at the current  sampling stage.\n\nNote that even if the sampling respects the schema it is assigned when ReservoirSample is instantiated, some ordering in  the sample can be more probable than others. To represent each one  with the same probability call shuffle! over the result.\n\n\n\n\n\n","category":"function"},{"location":"api/#StreamSampling.ordered_value","page":"API","title":"StreamSampling.ordered_value","text":"ordered_value(rs::AbstractReservoirSample)\n\nReturns the elements collected in the sample at the current  sampling stage in the order they were collected. This applies only when ordered = true is passed in ReservoirSample.\n\n\n\n\n\n","category":"function"},{"location":"api/#StreamSampling.itsample","page":"API","title":"StreamSampling.itsample","text":"itsample([rng], iter, method = algL)\nitsample([rng], iter, weight, method = algAExpJ)\n\nReturn a random element of the iterator, optionally specifying a rng  (which defaults to Random.default_rng()) and a weight function which accept each element as input and outputs the corresponding weight. If the iterator is empty, it returns nothing.\n\n\n\nitsample([rng], iter, method = algL; ordered = false)\nitsample([rng], iter, wv, method = algAExpJ; ordered = false)\n\nReturn a vector of n random elements of the iterator,  optionally specifying a rng (which defaults to Random.default_rng()) and a method. ordered dictates whether an ordered sample (also called a sequential  sample, i.e. a sample where items appear in the same order as in iter) must be  collected.\n\nIf the iterator has less than n elements, in the case of sampling without replacement, it returns a vector of those elements.\n\n\n\n\n\n","category":"function"},{"location":"api/#Algorithms","page":"API","title":"Algorithms","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"StreamSampling.algL\nStreamSampling.algR\nStreamSampling.algRSWRSKIP\nStreamSampling.algAExpJ\nStreamSampling.algARes\nStreamSampling.algWRSWRSKIP","category":"page"},{"location":"api/#StreamSampling.algL","page":"API","title":"StreamSampling.algL","text":"Implements random sampling without replacement.\n\nAdapted from algorithm L described in \"Random sampling with a reservoir, J. S. Vitter, 1985\".\n\n\n\n\n\n","category":"constant"},{"location":"api/#StreamSampling.algR","page":"API","title":"StreamSampling.algR","text":"Implements random sampling without replacement. \n\nAdapted from algorithm R described in \"Random sampling with a reservoir, J. S. Vitter, 1985\".\n\n\n\n\n\n","category":"constant"},{"location":"api/#StreamSampling.algRSWRSKIP","page":"API","title":"StreamSampling.algRSWRSKIP","text":"Implements random sampling with replacement.\n\nAdapted fron algorithm RSWR_SKIP described in \"Reservoir-based Random Sampling with Replacement from  Data Stream, B. Park et al., 2008\".\n\n\n\n\n\n","category":"constant"},{"location":"api/#StreamSampling.algAExpJ","page":"API","title":"StreamSampling.algAExpJ","text":"Implements weighted random sampling without replacement.\n\nAdapted from algorithm A-ExpJ described in \"Weighted random sampling with a reservoir,  P. S. Efraimidis et al., 2006\".\n\n\n\n\n\n","category":"constant"},{"location":"api/#StreamSampling.algARes","page":"API","title":"StreamSampling.algARes","text":"Implements weighted random sampling without replacement.\n\nAdapted from algorithm A-Res described in \"Weighted random sampling with a reservoir,  P. S. Efraimidis et al., 2006\".\n\n\n\n\n\n","category":"constant"},{"location":"api/#StreamSampling.algWRSWRSKIP","page":"API","title":"StreamSampling.algWRSWRSKIP","text":"Implements weighted random sampling with replacement.\n\nAdapted from algorithm WRSWR_SKIP described in \"A Skip-based Algorithm for Weighted Reservoir  Sampling with Replacement, A. Meligrana, 2024\". \n\n\n\n\n\n","category":"constant"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The scope of this package is providing general methods to sample from any stream in a single pass through the data, even when the number of items contained in the stream is unknown.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This has some advantages over other sampling procedures:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If the iterable is lazy, the memory required grows in relation to the size of the sample, instead of the all population.\nThe sample collected is a random sample of the portion of the stream seen thus far at any point of the sampling process.\nIn some cases, sampling with the techniques implemented in this library can bring considerable performance gains, since the population of items doesn't need to be previously stored in memory.","category":"page"},{"location":"#Brief-overview-of-the-functionalities","page":"Introduction","title":"Brief overview of the functionalities","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The itsample function allows to consume all the stream at once and return the sample collected:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using StreamSampling\n\njulia> st = 1:100;\n\njulia> itsample(st, 5)\n5-element Vector{Int64}:\n  9\n 15\n 52\n 96\n 91","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In some cases, one needs to control the updates the ReservoirSample will be subject to. In this case you can simply use the update! function to fit new values in the reservoir:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using StreamSampling\n\njulia> rs = ReservoirSample(Int, 5);\n\njulia> for x in 1:100\n           update!(rs, x)\n       end\n\njulia> value(rs)\n5-element Vector{Int64}:\n  7\n  9\n 20\n 49\n 74","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Consult the API page for more information on these and other functionalities.","category":"page"},{"location":"#Benchmark","page":"Introduction","title":"Benchmark","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"As stated in the first section, using these sampling techniques can bring down considerably the memory usage of the program,  but there are cases where they are also more time efficient, as demostrated below with a comparison with the  equivalent methods of StatsBase.sample:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using StreamSampling\n\njulia> using BenchmarkTools, Random, StatsBase\n\njulia> rng = Xoshiro(42);\n\njulia> iter = Iterators.filter(x -> x != 10, 1:10^7);\n\njulia> wv(el) = 1.0\n\njulia> @btime itsample($rng, $iter, 10^4, algRSWRSKIP);\n  11.744 ms (5 allocations: 156.39 KiB)\n\njulia> @btime sample($rng, collect($iter), 10^4; replace=true);\n  131.933 ms (20 allocations: 146.91 MiB)\n\njulia> @btime itsample($rng, $iter, 10^4, algL);\n  10.260 ms (3 allocations: 78.22 KiB)\n\njulia> @btime sample($rng, collect($iter), 10^4; replace=false);\n  132.069 ms (27 allocations: 147.05 MiB)\n\njulia> @btime itsample($rng, $iter, $wv, 10^4, algWRSWRSKIP);\n  32.278 ms (18 allocations: 547.34 KiB)\n\njulia> @btime sample($rng, collect($iter), Weights($wv.($iter)), 10^4; replace=true);\n  348.220 ms (49 allocations: 675.21 MiB)\n\njulia> @btime itsample($rng, $iter, $wv, 10^4, algAExpJ);\n  39.965 ms (11 allocations: 234.78 KiB)\n\njulia> @btime sample($rng, collect($iter), Weights($wv.($iter)), 10^4; replace=false);\n  306.039 ms (43 allocations: 370.19 MiB)","category":"page"}]
}
